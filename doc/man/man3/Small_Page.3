.TH "Small_Page" 3 "25 Sep 2008" "Embryo" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Small_Page \- Brief Introduction to Small 
This section describes the basics of Small, as compiled and interpreted with Embryo.
.PP
For the full documentation, of which this is a summary, see  
.PP
This summary assumes that you are familar with C. For a full list of differences between C and Small, again, see the full documentation.
.SH "Variables"
.PP
.SS "Types"
There is only one type, known as the 'cell', which can hold an integer.
.SS "Scope"
The scope and usage of a variable depends on its declaration.
.PP
.PD 0
.IP "\(bu" 2
A local variable is normally declared with the \fCnew\fP keyword. E.g. 
.PP
.nf
 new variable 

.fi
.PP
 
.IP "\(bu" 2
A static function variable is defined within a function with the \fCstatic\fP keyword. 
.IP "\(bu" 2
A global static variable is one that is only available within the file it was declared in. Again, use the \fCstatic\fP keyword, but outside of any function. 
.IP "\(bu" 2
A stock variable is one that may not be compiled into a program if it is not used. It is declared using \fCstock\fP. 
.IP "\(bu" 2
A public variable is one that can be read by the host program using \fBembryo_program_variable_find\fP. It is declared using \fCpublic\fP keyword.
.PP
Remember that the keywords above are to be used on their own. That is, for example: 
.PP
.nf
 public testvar 

.fi
.PP
 not: 
.PP
.nf
 new public testvar 

.fi
.PP
.SS "Constants"
You can declare constants in two ways: 
.PD 0

.IP "\(bu" 2
Using the preprocessor macro \fCdefine\fP. 
.IP "\(bu" 2
By inserting \fCconst\fP between the keyword and variable name of a variable declaration. For example, to declare the variable \fCvar1\fP constant, you type 
.PP
.nf
 new const var1 = 2 

.fi
.PP
 Now \fCvar1\fP cannot be changed.
.PP
.SS "Arrays"
To declare an array, append square brackets to the end of the variable name. The following examples show how to declare arrays. Note the use of the ellipsis operator, which bases the array based on the last two declared values:
.PP
.PP
.nf
new msg[] = 'A message.'
new ints[] = {1, 3, 4}
new ints2[20] = {1, 3}         // All other elements 0.
new ints3[10] = {1, ... }      // All elements = 1
new ints4[10] = {10, 20, ... } // Elements = 10 -> 100.
                               // The difference can be negative.
new ints5[3][3] = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}}
.fi
.PP
.PP
\fBNote:\fP
.RS 4
Array initialisers need to be constant.
.RE
.PP
.SH "Function Calls"
.PP
A typical function declaration is as follows:
.PP
.PP
.nf
testfunc(param) {
  // Do something ...
  // over a couple of lines.
}
.fi
.PP
.PP
You can pass by reference. That is, the parameter you pass is changed outside of the function. For example:
.PP
.PP
.nf
testfunc(&param) {
  param = 10
  // The passed variable will be set to 10 outside of the function.
}
.fi
.PP
.PP
To pass an array:
.PP
.PP
.nf
testfunc(param[]) {
  // Do something to the array
}
.fi
.PP
.PP
\fBNote:\fP
.RS 4
Arrays are passed by reference.
.RE
.PP
.SH "Control Structures."
.PP
Small has the following control structures, which similar to their C counterparts: 
.PD 0

.IP "\(bu" 2
.PP
.nf
 if (expression) statement1 else statement2 
.fi
.PP
 
.IP "\(bu" 2
.PP
.nf
 switch (expression) {
  case 0:
    statement1 // Can only be one statement.  Look Ma, no breaks!
  case 1..3:   // For values between 1 and 3 inclusive.
    statement2
  default:     // Optional
    statement3
}
.fi
.PP
 
.IP "\(bu" 2
.PP
.nf
 while(expression) statement 
.fi
.PP
 
.IP "\(bu" 2
.PP
.nf
 do statement while (expression) 
.fi
.PP
 
.IP "\(bu" 2
.PP
.nf
 for (init_expression; before_iter_test_expression; after_iter_expression) statement 
.fi
.PP

.PP
.SH "Preprocessor"
.PP
The following preprocessor directives are available: 
.PD 0

.IP "\(bu" 2
.PP
.nf
 #assert constant_expression 
.fi
.PP
 
.IP "\(bu" 2
.PP
.nf
 #define pattern replacement 
.fi
.PP
 
.IP "\(bu" 2
.PP
.nf
 #define pattern(%1,%2,...) replacement 
.fi
.PP
 
.IP "\(bu" 2
.PP
.nf
 #include filename 
.fi
.PP
 
.IP "\(bu" 2
.PP
.nf
 #if constant_expression
  // Various bits of code
#else
  // Other bits of code
#endif 
.fi
.PP
 
.IP "\(bu" 2
.PP
.nf
 #undef pattern 
.fi
.PP
 
.PP

